read "guessing.mpl":
read "EMGCD.mpl":
read "univariate.mpl":
read "extension.mpl":
with(Groebner):
with(PolynomialTools):

Hankel_solver_onevar := proc(r0,r1,d0)
description "r0 represents the sequence u of order d0 and r1 represents the sequence v in "
    "LU. The solver returns h in K[x] such that v = hu":
local vectr0, vectr1, vecth, h, i:
    vectr0 := [seq(coeff(r0, x, degree(r0) -i), i=0..2*(d0-1))]:
    vectr1 := [seq(coeff(r1, x, degree(r1)-i), i=0..d0-1)]:
    vecth := HankelADT(d0-1, vectr0, vectr1, x, p):
    h := 0:
    for i from 1 to d0 do
        h := h + vecth[i] * x^(i-1) mod p:
    end do:
    return h:
end proc:

Extraction_xaxis := proc(P, dx)
description "Remove the unknown terms in x":
local P_extracted, i:
    if (dx <> -infinity) then
        #Remove terms outside the initial parallelotope
        # P_extracted := Rem(P, y^(Dy+1), y) mod p:
        P_extracted := Rem(P, x^(Dx+1), x) mod p:
        #Remove unknown terms from operations
        P_extracted := Quo(P_extracted, x^(Dx-dx+1), x) mod p:
        return P_extracted:
    else
        return P:
    end if:
end proc:

Extension_univariate := proc(r,g)
description "Extend r in K[x] with deg(r) >= deg(g)-1 and compute the first 2deg(g) "
    "terms of the sequence v with initial terms r and with relation g":
local v, vi, vect_g, d, i,j:
    v := CoefficientList(r, x, termorder = reverse):
    vect_g := CoefficientList(g, x):
    d := degree(g):
    for i from d to 2*d do
        vi := 0:
        for j from 1 to d do
            vi := vi - v[j+i-d]*vect_g[j] mod p:
        end do:
        v := [op(v), vi]:
    end do:
    return FromCoefficientList(v, x, termorder = reverse):
end proc:

Extension_twovar_onerelation := proc(r,g)
description "Extend r = sum_{i = 0}^dy ri(x) y^i in K[x,y] and g in K[x] with"
    "deg(ri) >= deg(g)-1 and compute the terms of the sequence v in the (2dx,dy)-parallelotope "
    "with initial terms r and relation g":
local r_extended, rx, dy, j:
    if g <> 0 then
        dy := degree(r,y):
        r_extended := 0:
        for j from 0 to dy do
            rx := coeff(r,y,j):
            if (rx <> 0) then
                rx := reciprocal(rx, degree(rx), x):
                rx := reciprocal(extension_tellegen(g, rx, 2*degree(g), p), 2*degree(g), x):
            end if:
            r_extended := r_extended + rx*y^j:
        end do:
        return r_extended:
    else
        return r:
    end if:
end proc:

Quo_twovar := proc(r0, r1)
description "Compute the matrix Q1 in (Lu)[y]^{2x2} such that [[r1],[r2]] = Q1 [[r0],[r1]] "
    "with deg(r2) = deg(r1) - 1 and Lu is the linear subspace of K^N generated by "
    "the minimal polynomial of the sequence u":
local a, b, lcr0, lcr1, r2temp, lcr2temp, d0, g0, d1, g1:
    lcr0 := lcoeff(r0, y):
    lcr1 := lcoeff(r1, y):
    # by normal case hyp: deg(r0) = deg(r1) + 1
    # r0 = u0 y^d + ...
    # r1 = u1 y^(d-1) + ...
    # g0 in I(u0)
    g0 := BM_Euclid(lcr0, degree(lcr0)):
    d0 := degree(g0):
    if (lcr0 = 1) then
        a := lcr1:
    else
        a := Hankel_solver_onevar(lcr0, lcr1, d0):
    end if:
    # g1 in I(u1)
    g1 := BM_Euclid(lcr1, degree(lcr1)):
    d1 := degree(g1):
    # deg(r2temp) = deg(r1)
    r2temp := Extraction_xaxis(y*r1-a*r0, d1):
    r2temp := Extension_twovar_onerelation(r2temp, g1):
    lcr2temp := lcoeff(r2temp, y):
    if (lcr2temp = 0) then
        return Matrix([[0,1],[-a, y]]), g1:
    else
        b := Hankel_solver_onevar(lcr1, lcr2temp, d1):
        return Matrix([[0,1],[-a, y-b]]), g1:
    end if:
end proc:

Truncated_Euclidean_twoindseq := proc(r0,r1)
description "For two polynomials with coefficients in sequence ring computes the "
    "consecutive  remainder r=(ri) and the cofactors u = (ui), v = (vi) also its "
    "computes the":
local G, r, u, v, i, Qi, gi, ri1, ui1, vi1:
    G := []:
    r := [r0, r1]:
    u := [1,0]:
    v := [0,1]:
    for i from 2 to degree(r0,y) + 1 while degree(r[i],y) >= degree(v[i],y) do
        Qi, gi := Quo_twovar(r[i-1], r[i]):
        G := [op(G), gi]:
        # TODO comment
        ri1 := Extraction_xaxis(Qi[2,1]*r[i-1] + Qi[2,2]*r[i], degree(G[1])):
        ri1 := sort(expand(Extension_twovar_onerelation(ri1, G[1]) mod p, order = ord)):
        r := [op(r), sort(expand(ri1) mod p, order = ord)]:
        u := [op(u), sort(expand(Qi[2,1]*u[i-1] + Qi[2,2]*u[i]) mod p, order = ord)]:
        v := [op(v), sort(expand(Qi[2,1]*v[i-1] + Qi[2,2]*v[i]) mod p, order = ord)]:
    end do:
    G := [op(G), 1]:
    return r,u,v,G:
end proc:

BM_Euclid_twovar := proc(P, Dy)
description "Generalization of the BM algorithm for 2-indiced C-recursive sequence "
    "computation of the relation done iteratively with recursive call to the uni-indiced "
    "sequence computed with Euclid algorithm":
local r0, r1, G, r, u, v, i:
    r0 := y^(Dy+1):
    r1 := P:
    r,u,v,G := Truncated_Euclidean_twoindseq(r0, r1):
    G := [seq(v[i+1] * G[i], i=1..nops(G))]:
    return Groebner:-Basis (G, ord, characteristic = p):
end proc:

######################
#     Context        #
######################
p := 65537:
vars := [x,y]:
ord := plex(y,x):                        # y > x
# F := [seq(randpoly(vars, dense, degree=1)^4, i=1..2)];
Gu := Groebner:-Basis ([(x-1)^2, (x-1)*(y-1), y^2-x],ord, characteristic = p);

Gux := [seq(lcoeff(Gu[i], y), i = 1..nops(Gu))]:
LMGu := LeadingMonomial(Gu, ord);
Dx:= 2*degree(LMGu[1]);                 #LMGu[1] = x^dx
Dy:= 2*degree(LMGu[-1]);                #LMGu[-1] = y^dy
M:= x^Dx*y^Dy;
initTab := proc(i,j)
description "init":
local k:
    if (i,j) = (0,0) then return 1: end if:
    if (i,j) = (1,0) then return 2: end if:
    if (i,j) = (0,1) then return 3: end if:
end proc:
Tab := fromGbToExtendedTab(Gu, vars, ord, initTab, p):


mon:= sortListMon ([seq (seq (x^i*y^j,j=0..Dy),i=0..Dx)], ord):
P:=from1SetToMirrorTruncatedGeneratingSeries (Tab,vars,mon):

######################
# Hankel Solver test #
######################
d0 := degree(LMGu[1]):
r0 := lcoeff(P, y):
r1 := coeff(P, y, Dy - 1):
h := Hankel_solver_onevar(r0, r1, d0):
r1_reduced := Rem(r1 - h*r0, x^(Dx+1), x) mod p: #Remove unknown terms
if (degree(r1_reduced) < d0) then
    print("Hankel_Solver ok"):
else
    print("Hankel_Solver not ok"):
end if:

###############################
# Extension & Extraction test #
###############################

# Extend univariate polynomial from one relation
r0_trunc := Quo(r0, x^(Dx-d0+1), x) mod p:
# trace(Extension):
time_naif := time():
rstar1 := Extension_univariate(r0_trunc, Gu[1]):
time_naif := time() - time_naif:

time_tell := time():
rstar2 := reciprocal(extension_tellegen(Gu[1], reciprocal(r0_trunc, degree(r0_trunc), x), degree(r0), p), degree(r0), x):
time_tell := time() - time_tell:

# print("naif", time_naif):
# print("tell", time_tell):

if (r0 mod p = rstar1) then
    print("Extension ok"):
else
    print("Extension not ok"):
end if:
# Extend two variate polynomial from one relation
P_trunc := Extraction_xaxis(P, d0):

time_twonaif := time():
Pstar := Extension_twovar_onerelation(P_trunc, Gu[1]):
time_twonaif := time() - time_twonaif:

Pstar := expand(Pstar) mod p:
if (P mod p= Pstar) then
    print("Extension_twovar_onerelation ok"):
else
    print("Extension_twovar_onerelation not ok"):
end if:

##################
# QuoRem two var #
##################
#Limit case / Initial case
r0 := y^(Dy+1):
r1 := P:
Q1, g1 := Quo_twovar(r0,r1):
r2 := sort(expand(Q1[2,1]*r0 + Q1[2,2]*r1) mod p, order =ord):
r2 := expand(Extraction_xaxis(r2, degree(g1))) mod p:
if (degree(r1,y) = degree(r2, y) +1) then
          print("Quo_twovar ok"):
      else
          print("Quo_twovar not ok"):
      end if:

###############################
# Compute the reduced GrÃ¶bner #
# basis of (u_{i,j})          #
###############################
Gres := BM_Euclid_twovar(P, Dy):
if Gu = Gres then
    print("BM_Euclid_twovar ok"):
else
    print("BM_Euclid_twovar not ok"):
end if:
