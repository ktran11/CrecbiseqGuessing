read "guessing.mpl":
read "EMGCD.mpl":
read "univariate.mpl":
read "extension.mpl":
with(Groebner):
with(PolynomialTools):

Hankel_solver_onevar := proc(r0,r1,d0)
description "r0 represents the sequence u of order d0 and r1 represents the sequence v in "
    "LU. The solver returns h in K[x] such that v = hu":
local vectr0, vectr1, vecth, h, i:
    vectr0 := [seq(coeff(r0, x, degree(r0,x) - i), i=0..2*(d0-1))]:
    vectr1 := [seq(coeff(r1, x, degree(r1,x) - i), i=0..d0-1)]:
    vecth := HankelADT(d0-1, vectr0, vectr1, x, p):
    h := 0:
    for i from 1 to d0 do
        h := h + vecth[i] * x^(i-1) mod p:
    end do:
    return h:
end proc:

Extraction_xaxis := proc(P, dx, DDx)
description "Remove the unknown terms in x":
local P_extracted, i:
    if (dx <> -infinity) then
        #Remove terms outside the initial parallelotope
        # P_extracted := Rem(P, y^(Dy+1), y) mod p:
        P_extracted := Rem(P, x^(DDx+1), x) mod p:
        #Remove unknown terms from operations
        P_extracted := Quo(P_extracted, x^(DDx-dx+1), x) mod p:
        return P_extracted:
    else
        return P:
    end if:
end proc:

Extension_twovar_onerelation := proc(r,g, DDx)
description "Extend r = sum_{i = 0}^dy ri(x) y^i in K[x,y] and g in K[x] with"
    "deg(ri) >= deg(g)-1 and compute the terms of the sequence v in the (2dx,dy)-parallelotope "
    "with initial terms r and relation g":
local r_extended, rx, dy, j:
    if g <> 0 then
        dy := degree(r,y):
        r_extended := 0:
        for j from 0 to dy do
            rx := coeff(r,y,j):
            if (rx <> 0) then
                rx := reciprocal(rx, degree(rx), x):
                rx := reciprocal(extension_tellegen(g, rx, DDx, p), DDx, x):
            end if:
            r_extended := r_extended + rx*y^j:
        end do:
        return r_extended:
    else
        return r:
    end if:
end proc:

Quo_twovar := proc(r0, r1)
description "Compute the matrix Q1 in (Lu)[y]^{2x2} such that [[r1],[r2]] = Q1 [[r0],[r1]] "
    "with deg(r2) = deg(r1) - 1 and Lu is the linear subspace of K^N generated by "
    "the minimal polynomial of the sequence u":
local DDx, a, b, lcr0, lcr1, r2temp, lcr2temp, d0, g0, d1, g1, d:
    d := degree(r0, y):
    if d <> degree(r1, y) +1 then
        print("Error Quotwovar degree"):
    end if:
    lcr0 := lcoeff(r0, y):
    lcr1 := lcoeff(r1, y):
    DDx := degree(lcr0,x):
    # by normal case hyp: deg(r0) = deg(r1) + 1
    # r0 = u0 y^d + ...
    # r1 = u1 y^(d-1) + ...
    # g0 in I(u0)
    g0 := GuessingUnivar(lcr0):
    d0 := degree(g0,x):
    a := Hankel_solver_onevar(lcr0, lcr1, d0):
# g1 in I(u1)
    g1 := GuessingUnivar(lcr1):
    d1 := degree(g1,x):
# deg(r2temp) = deg(r1)
    r2temp := Extraction_xaxis(y*r1-a*r0 mod p, d1, DDx):
    r2temp := Extension_twovar_onerelation(r2temp, g1, DDx):
    lcr2temp := coeff(r2temp, y^(d-1)):
    b := Hankel_solver_onevar(lcr1, lcr2temp, d1):

    return Matrix([[0,1],[-a, y-b]]), g1:
end proc:

Truncated_Euclidean_twoindseq := proc(r0,r1)
description "For two polynomials with coefficients in sequence ring computes the "
    "consecutive  remainder r=(ri) and the cofactors u = (ui), v = (vi) also its "
    "computes the":
local G, r, u, v, i, Qi, gi, ri1, ui1, vi1:
    G := []:
    r := [r0, r1]:
    u := [1,0]:
    v := [0,1]:
    for i from 2 to degree(r0,y) + 1 while degree(r[i],y) >= degree(v[i],y) do
        Qi, gi := Quo_twovar(r[i-1], r[i]):
        G := [op(G), gi]:
        # TODO comment
        ri1 := Extraction_xaxis(Qi[2,1]*r[i-1] + Qi[2,2]*r[i], degree(G[1])):
        ri1 := sort(expand(Extension_twovar_onerelation(ri1, G[1]) mod p, order = ord)):
        r := [op(r), sort(expand(ri1) mod p, order = ord)]:
        u := [op(u), sort(expand(Qi[2,1]*u[i-1] + Qi[2,2]*u[i]) mod p, order = ord)]:
        v := [op(v), sort(expand(Qi[2,1]*v[i-1] + Qi[2,2]*v[i]) mod p, order = ord)]:
    end do:
    G := [op(G), 1]:
    return r,u,v,G:
end proc:

BM_Euclid_twovar := proc(P, Dy)
description "Generalization of the BM algorithm for 2-indiced C-recursive sequence "
    "computation of the relation done iteratively with recursive call to the uni-indiced "
    "sequence computed with Euclid algorithm":
local r0, r1, G, r, u, v, i:
    r0 := y^(Dy+1):
    r1 := P:
    r,u,v,G := Truncated_Euclidean_twoindseq(r0, r1):
    G := [seq(v[i+1] * G[i], i=1..nops(G))]:
    return Groebner:-Basis (G, ord, characteristic = p):
end proc:
